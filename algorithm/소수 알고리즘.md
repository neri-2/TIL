# 소수 알고리즘

## 에라토스테네스의 체

소수를 찾는 방법, 에라토스테네스가 발견

### 알고리즘

---

1. 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.
2. 2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)
3. 자기 자신을 제외한 2의 배수를 모두 지운다.
4. 남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)
5. 자기 자신을 제외한 3의 배수를 모두 지운다.
6. 남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)
7. 자기 자신을 제외한 5의 배수를 모두 지운다.
8. 남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)
9. 자기 자신을 제외한 7의 배수를 모두 지운다.
10. 위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.

<img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif">

### C++로 구현한 코드

---

#### 내가 구현한 코드

```c++
void Eratos() {
	bool arr[1001] = { 0, };
	arr[0] = true;
	arr[1] = true; // 0과 1 예외 처리
	for (int i = 2; i <= 1000; i++) {
		if (arr[i]) // 소수 아닌 수 건너뛰기
			continue;
		for (int j = 2 * i; j <= 1000; j += i) {
			arr[j] = true; // 소수를 제외한 배수 지우기
		}
	}
}
```

#### 위키피디아 코드

```c++
void Eratos(int n)
{
    /*  만일 n이 1보다 작거나 같으면 함수 종료 */
    if (n <= 1) return;

    /*	2부터 n까지 n-1개를 저장할 수 있는 배열 할당
		배열 참조 번호와 소수와 일치하도록 배열의 크기는
		n+1 길이만큼 할당(인덱스 번호 0과 1은 사용하지 않음)	*/
	bool* PrimeArray = new bool[n + 1];

	/*  배열초기화: 처음엔 모두 소수로 보고 true값을 줌	*/
	for (int i = 2; i <= n; i++)
	    PrimeArray[i] = true;

	/*	에라토스테네스의 체에 맞게 소수를 구함
		만일, PrimeArray[i]가 true이면 i 이후의 i 배수는 약수로 i를
		가지고 있는 것이 되므로 i 이후의 i 배수에 대해 false값을 준다.
		PrimeArray[i]가 false이면 i는 이미 소수가 아니므로 i의 배수 역시
		소수가 아니게 된다. 그러므로 검사할 필요도 없다.
또한 i*k (k < i) 까지는 이미 검사되었으므로 j시작 값은 i*2 에서 i*i로 개선할 수 있다.
	*/
	for (int i = 2; i * i <= n; i++)
	{
		if (PrimeArray[i])
			for (int j = i * i; j <= n; j += i)
			    PrimeArray[j] = false;
	}

	// 이후의 작업 ...
}
```

#### 알고리즘을 이용하지 않은 코드

```c++
void Error() {
	int M, N;
	cin >> M >> N; // M부터 N까지의 소수를 구하는 문제
	for (int i = M; i <= N; i++) {
		bool k = false;
		for (int j = 2; j < i; j++) { // 2부터 해당 숫자 직전까지 나누기
			if (i % j == 0) {
				k = true; // 나머지가 0이 되는 경우 소수가 아님을 표시
				break;
			}
		}
		if (!k)
			cout << i << '\n'; // 소수인 경우 출력
	}
}
```

결과: 시간초과

### 배운점

---

알고리즘을 사용하지 않은 코드에서는 이중포문을 이용하여 한 숫자에 대해 2부터 그 숫자까지 계속 나누는 방법을 사용하여 나머지가 0이 아닌 수를 찾는 방법을 사용하였다.
일일이 모든 수를 그 수의 크기만큼 나누는 작업을 수행하다 보니 굉장히 오랜 시간이 걸리게 되었다.

알고리즘을 사용한 후 시간도 절약할 수 있었고 다양한 상황에서도 사용가능한 코드를 작성할 수 있었다.

배열(포인터)의 활용법에 대해서도 조금 더 알아가는 기회가 되었다.
